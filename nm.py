# -*- coding: utf-8 -*-
"""nm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dyVb0CbAVEGdonRgeKXmEqMlCvp4w0oU
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

# Load the dataset
file_path = '/mnt/data/house-prices-100.xlsx'
df = pd.read_excel('/content/house-prices-100.xlsx')

# Remove duplicate rows
df.drop_duplicates(inplace=True)

# Handle outliers in 'SqFt' using IQR method
Q1 = df['SqFt'].quantile(0.25)
Q3 = df['SqFt'].quantile(0.75)
IQR = Q3 - Q1
lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR
df['SqFt'] = df['SqFt'].clip(lower, upper)

# Create a 'Luxury_Index' feature
# Assuming 'Brick' is a binary feature and 'Offers' reflects demand
# Combining them as a proxy for luxury
# **Adjust as per your dataset context if needed**
df['Luxury_Index'] = (df['Bathrooms'] + df['Bedrooms']) * df['Brick']

# Create 'Price_per_sqft' feature
# Preventing divide by zero errors
df['Price_per_sqft'] = df['Price'] / df['SqFt'].replace(0, np.nan)

# Normalize numerical features
scaler = MinMaxScaler()
num_cols = ['SqFt', 'Bedrooms', 'Bathrooms', 'Price', 'Price_per_sqft']
df[num_cols] = scaler.fit_transform(df[num_cols])

# Final structure check
print(df.info())
print(df.describe())
df.drop_duplicates(inplace=True)

# Handle outliers in 'SqFt' using IQR method
Q1 = df['SqFt'].quantile(0.25)
Q3 = df['SqFt'].quantile(0.75)
IQR = Q3 - Q1
lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR
df['SqFt'] = df['SqFt'].clip(lower, upper)

# Create a 'Luxury_Index' feature
# Assuming 'Brick' is a binary feature and 'Offers' reflects demand
# Combining them as a proxy for luxury
# **Adjust as per your dataset context if needed**
# Ensure 'Brick' is of numeric type before multiplication
df['Luxury_Index'] = (df['Bathrooms'] + df['Bedrooms']) * df['Brick'].map({'Yes': 1, 'No': 0})
# Create 'Price_per_sqft' feature
# Preventing divide by zero errors
df['Price_per_sqft'] = df['Price'] / df['SqFt'].replace(0, np.nan)

# Normalize numerical features
scaler = MinMaxScaler()
num_cols = ['SqFt', 'Bedrooms', 'Bathrooms', 'Price', 'Price_per_sqft']
df[num_cols] = scaler.fit_transform(df[num_cols])

# Final structure check
print(df.info())
print(df.describe())
df.drop_duplicates(inplace=True)